require("dotenv").config();
const { Telegraf, Markup } = require("telegraf");
const { MongoClient } = require("mongodb");

// ======================
// âš¡ Initialisation
// ======================
const bot = new Telegraf(process.env.BOT_TOKEN);
const client = new MongoClient(process.env.MONGO_URI);
const LOG_CHAT_ID = process.env.LOG_CHAT_ID; // Chat ID pour les logs admin

(async () => {
  try {
    await client.connect();
    console.log("âœ”ï¸ ConnectÃ© Ã  MongoDB");

    const db = client.db("telegram_bot");
    const warns = db.collection("warnings");
    const messages = db.collection("messages");
    const accepted = db.collection("accepted_rules");

    // ======================
    // ğŸ“ Fonction log admin
    // ======================
    async function logAdmin(text) {
      try {
        await bot.telegram.sendMessage(LOG_CHAT_ID, `ğŸ“ LOG:\n${text}`);
      } catch (e) {
        console.log("âš ï¸ Erreur LOG :", e);
      }
    }

    // ======================
    // ğŸ§¹ Nettoyage automatique des logs (50 derniers)
    // ======================
    async function cleanLogs() {
      // Si tu veux gÃ©rer les logs, fais-le depuis MongoDB
      const count = await messages.countDocuments();
      if (count > 50) {
        const toDelete = await messages.find().sort({ date: 1 }).limit(count - 50).toArray();
        const ids = toDelete.map(m => m._id);
        await messages.deleteMany({ _id: { $in: ids } });
        console.log("ğŸ§¹ Logs MongoDB nettoyÃ©s");
      }
    }
    setInterval(cleanLogs, 30 * 60 * 1000); // toutes les 30 min

    // ======================
    // ğŸš¨ Nouveau membre / RÃ¨gles / Acceptation
    // ======================
    bot.on("new_chat_members", async (ctx) => {
      const user = ctx.message.new_chat_members[0];
      const chatId = ctx.chat.id;

      if (user.is_bot) return;

      // Bloquer le membre (lecture seule)
      await ctx.restrictChatMember(user.id, {
        permissions: {
          can_send_messages: false,
          can_send_media_messages: false,
          can_send_other_messages: false,
          can_add_web_page_previews: false
        }
      });

      // Enregistrer en DB (non acceptÃ©)
      await accepted.updateOne(
        { userId: user.id, chatId },
        { $set: { userId: user.id, chatId, accepted: false } },
        { upsert: true }
      );

      await ctx.reply(
`ğŸ‘‹ Bienvenue **${user.first_name}** !
Avant de parler, tu dois accepter les rÃ¨gles du groupe.`,
        {
          parse_mode: "Markdown",
          ...Markup.inlineKeyboard([
            [Markup.button.callback("âœ… Jâ€™accepte les rÃ¨gles", `accept_${user.id}`)],
            [Markup.button.url("ğŸ“œ Voir les rÃ¨gles", "https://t.me/ton_groupe")]
          ])
        }
      );

      logAdmin(`ğŸ›‘ Nouveau membre en attente : ${user.first_name} (${user.id})`);
    });

    // ======================
    // âœ… Bouton Accept
    // ======================
    bot.action(/accept_\d+/, async (ctx) => {
      const userId = Number(ctx.callbackQuery.data.split("_")[1]);
      const chatId = ctx.chat.id;

      if (ctx.from.id !== userId) {
        return ctx.answerCbQuery("âŒ Ce bouton nâ€™est pas pour toi.");
      }

      // Update DB
      await accepted.updateOne(
        { userId, chatId },
        { $set: { accepted: true } },
        { upsert: true }
      );

      // Autoriser Ã  parler
      await ctx.restrictChatMember(userId, {
        permissions: {
          can_send_messages: true,
          can_send_media_messages: true,
          can_send_other_messages: true,
          can_add_web_page_previews: true
        }
      });

      await ctx.editMessageText("ğŸ‰ Tu as acceptÃ© les rÃ¨gles, bienvenue !");
      await ctx.answerCbQuery("AccÃ¨s accordÃ© ğŸ‘");

      logAdmin(`âœ”ï¸ RÃ¨gles acceptÃ©es : ${ctx.from.first_name} (${userId})`);
    });

    // ======================
    // ğŸ›¡ï¸ Blocage messages si non acceptÃ©
    // ======================
    bot.use(async (ctx, next) => {
      if (!ctx.message || !ctx.from || !ctx.chat) return next();

      const userId = ctx.from.id;
      const chatId = ctx.chat.id;

      // Ignorer admins
      const member = await ctx.telegram.getChatMember(chatId, userId);
      if (["administrator", "creator"].includes(member.status)) return next();

      const ruleOK = await accepted.findOne({ userId, chatId, accepted: true });
      if (!ruleOK) {
        try { await ctx.deleteMessage(); } catch {}
        return;
      }

      next();
    });

    // ======================
    // âŒ Anti-spam / Anti-link
    // ======================
    bot.on("message", async (ctx, next) => {
      const user = ctx.from;
      const chatId = ctx.chat.id;
      const text = (ctx.message.text || "").toLowerCase();

      // Anti-link
      const linkPatterns = ["http://", "https://", "t.me/", "www."];
      if (linkPatterns.some(x => text.includes(x))) {
        await ctx.deleteMessage();
        let W = await warns.findOne({ userId: user.id, chatId });
        if (!W) W = { userId: user.id, chatId, warns: 0 };
        W.warns++;
        await warns.updateOne({ userId: user.id, chatId }, { $set: W }, { upsert: true });
        logAdmin(`âš ï¸ Lien supprimÃ© : ${user.first_name} warn ${W.warns}/3`);
        if (W.warns >= 3) {
          await ctx.telegram.banChatMember(chatId, user.id);
          await warns.deleteOne({ userId: user.id, chatId });
          ctx.reply(`ğŸš« ${user.first_name} banni (3 warns - liens)`);
          logAdmin(`ğŸš« BAN : ${user.first_name} (3 warns - liens)`);
        } else {
          ctx.reply(`âš ï¸ @${user.username || user.first_name} warn ${W.warns}/3 â€” **Liens interdits**`);
        }
        return;
      }

      // Anti-spam
      await messages.insertOne({
        userId: user.id,
        chatId,
        text: ctx.message.text || "",
        date: Date.now(),
      });

      const recent = await messages
        .find({ userId: user.id, date: { $gt: Date.now() - 10000 } })
        .toArray();

      const spamPatterns = ["porn", "sex", "crypto", "promo", "airdrop", "earn money", "hentai", "free money"];
      const isSpam = spamPatterns.some(p => text.includes(p));

      if (recent.length >= 5 || isSpam) {
        await ctx.deleteMessage();
        logAdmin(`ğŸ—‘ï¸ Spam supprimÃ© : ${user.first_name} â€” ${text}`);

        let W = await warns.findOne({ userId: user.id, chatId });
        if (!W) W = { userId: user.id, chatId, warns: 0 };
        W.warns++;
        await warns.updateOne({ userId: user.id, chatId }, { $set: W }, { upsert: true });

        if (W.warns >= 3) {
          await ctx.telegram.banChatMember(chatId, user.id);
          await warns.deleteOne({ userId: user.id, chatId });
          ctx.reply(`ğŸš« ${user.first_name} banni (3 warns spam)`);
        } else {
          ctx.reply(`âš ï¸ Warn ${W.warns}/3 pour spam`);
        }
      }

      next();
    });

    // ======================
    // ğŸ“œ Commande /regles
    // ======================
    bot.command("regles", async (ctx) => {
      await ctx.replyWithMarkdown(`
ğŸ“œ **RÃˆGLES DU GROUPE**

1ï¸âƒ£ Pas de spam ni flood  
2ï¸âƒ£ Pas de liens (pub, arnaques, t.me, sites douteux)  
3ï¸âƒ£ Pas d'insultes / manque de respect  
4ï¸âƒ£ Pas de contenu porno, gore, haineux  
5ï¸âƒ£ Pas de vente, crypto, airdrop, arnaques  
6ï¸âƒ£ Restez courtois, entraidez-vous ğŸ‘  

âš ï¸ Le non-respect des rÃ¨gles = warn â†’ bannissement automatique.
      `);
    });

    // ======================
    // ğŸš€ Lancement du bot
    // ======================
    bot.launch();
    console.log("ğŸš€ BOT FULL SECURITY ACTIVÃ‰");
  } catch (err) {
    console.error("âŒ Erreur MongoDB :", err);
  }
})();
